/// <reference types="node" />
import { Awaited } from '../util/util';
import { VoiceConnection } from '../VoiceConnection';
import { AudioPlayerError } from './AudioPlayerError';
import { AudioResource } from './AudioResource';
import { PlayerSubscription } from './PlayerSubscription';
import { TypedEmitter } from 'tiny-typed-emitter';
export declare const SILENCE_FRAME: Buffer;
/**
 * Describes the behavior of the player when an audio packet is played but there are no available
 * voice connections to play to.
 */
export declare enum NoSubscriberBehavior {
    /**
     * Pauses playing the stream until a voice connection becomes available
     */
    Pause = "pause",
    /**
     * Continues to play through the resource regardless
     */
    Play = "play",
    /**
     * The player stops and enters the Idle state
     */
    Stop = "stop"
}
export declare enum AudioPlayerStatus {
    /**
     * When there is currently no resource for the player to be playing
     */
    Idle = "idle",
    /**
     * When the player is waiting for an audio resource to become readable before transitioning to Playing
     */
    Buffering = "buffering",
    /**
     * When the player has been manually paused
     */
    Paused = "paused",
    /**
     * When the player is actively playing an audio resource
     */
    Playing = "playing",
    /**
     * When the player has paused itself. Only possible with the "pause" no subscriber behavior.
     */
    AutoPaused = "autopaused"
}
/**
 * Options that can be passed when creating an audio player, used to specify its behavior.
 */
export interface CreateAudioPlayerOptions {
    debug?: boolean;
    behaviors?: {
        noSubscriber?: NoSubscriberBehavior;
        maxMissedFrames?: number;
    };
}
/**
 * The state that an AudioPlayer is in when it has no resource to play. This is the starting state.
 */
export interface AudioPlayerIdleState {
    status: AudioPlayerStatus.Idle;
}
/**
 * The state that an AudioPlayer is in when it is waiting for a resource to become readable. Once this
 * happens, the AudioPlayer will enter the Playing state. If the resource ends/errors before this, then
 * it will re-enter the Idle state.
 */
export interface AudioPlayerBufferingState {
    status: AudioPlayerStatus.Buffering;
    /**
     * The resource that the AudioPlayer is waiting for
     */
    resource: AudioResource;
    onReadableCallback: () => void;
    onFailureCallback: () => void;
    onStreamError: (error: Error) => void;
}
/**
 * The state that an AudioPlayer is in when it is actively playing an AudioResource. When playback ends,
 * it will enter the Idle state.
 */
export interface AudioPlayerPlayingState {
    status: AudioPlayerStatus.Playing;
    /**
     * The number of consecutive times that the audio resource has been unable to provide an Opus frame.
     */
    missedFrames: number;
    /**
     * The playback duration in milliseconds of the current audio resource. This includes filler silence packets
     * that have been played when the resource was buffering.
     */
    playbackDuration: number;
    /**
     * The resource that is being played
     */
    resource: AudioResource;
    onStreamError: (error: Error) => void;
}
/**
 * The state that an AudioPlayer is in when it has either been explicitly paused by the user, or done
 * automatically by the AudioPlayer itself if there are no available subscribers.
 */
export interface AudioPlayerPausedState {
    status: AudioPlayerStatus.Paused | AudioPlayerStatus.AutoPaused;
    /**
     * How many silence packets still need to be played to avoid audio interpolation due to the stream suddenly pausing
     */
    silencePacketsRemaining: number;
    /**
     * The playback duration in milliseconds of the current audio resource. This includes filler silence packets
     * that have been played when the resource was buffering.
     */
    playbackDuration: number;
    /**
     * The current resource of the audio player
     */
    resource: AudioResource;
    onStreamError: (error: Error) => void;
}
/**
 * The various states that the player can be in.
 */
export declare type AudioPlayerState = AudioPlayerIdleState | AudioPlayerBufferingState | AudioPlayerPlayingState | AudioPlayerPausedState;
export declare type AudioPlayerEvents = {
    error: (error: AudioPlayerError) => Awaited<void>;
    debug: (message: string) => Awaited<void>;
    stateChange: (oldState: AudioPlayerState, newState: AudioPlayerState) => Awaited<void>;
    subscribe: (subscription: PlayerSubscription) => Awaited<void>;
    unsubscribe: (subscription: PlayerSubscription) => Awaited<void>;
} & {
    [status in AudioPlayerStatus]: (oldState: AudioPlayerState, newState: AudioPlayerState) => Awaited<void>;
};
/**
 * Used to play audio resources (i.e. tracks, streams) to voice connections.
 *
 * @remarks
 * Audio players are designed to be re-used - even if a resource has finished playing, the player itself
 * can still be used.
 *
 * The AudioPlayer drives the timing of playback, and therefore is unaffected by voice connections
 * becoming unavailable. Its behavior in these scenarios can be configured.
 */
export declare class AudioPlayer extends TypedEmitter<AudioPlayerEvents> {
    /**
     * The state that the AudioPlayer is in
     */
    private _state;
    /**
     * A list of VoiceConnections that are registered to this AudioPlayer. The player will attempt to play audio
     * to the streams in this list.
     */
    private readonly subscribers;
    /**
     * The behavior that the player should follow when it enters certain situations.
     */
    private readonly behaviors;
    /**
     * The debug logger function, if debugging is enabled.
     */
    private readonly debug;
    /**
     * Creates a new AudioPlayer
     */
    constructor(options?: CreateAudioPlayerOptions);
    /**
     * A list of subscribed voice connections that can currently receive audio to play
     */
    get playable(): VoiceConnection[];
    /**
     * Subscribes a VoiceConnection to the audio player's play list. If the VoiceConnection is already subscribed,
     * then the existing subscription is used.
     *
     * @remarks
     * This method should not be directly called. Instead, use VoiceConnection#subscribe.
     *
     * @param connection - The connection to subscribe
     * @returns The new subscription if the voice connection is not yet subscribed, otherwise the existing subscription.
     */
    private subscribe;
    /**
     * Unsubscribes a subscription - i.e. removes a voice connection from the play list of the audio player.
     *
     * @remarks
     * This method should not be directly called. Instead, use PlayerSubscription#unsubscribe.
     *
     * @param subscription - The subscription to remove
     * @returns Whether or not the subscription existed on the player and was removed.
     */
    private unsubscribe;
    /**
     * The state that the player is in.
     */
    get state(): AudioPlayerState;
    /**
     * Sets a new state for the player, performing clean-up operations where necessary.
     */
    set state(newState: AudioPlayerState);
    /**
     * Plays a new resource on the player. If the player is already playing a resource, the existing resource is destroyed
     * (it cannot be reused, even in another player) and is replaced with the new resource.
     *
     * @remarks
     * The player will transition to the Playing state once playback begins, and will return to the Idle state once
     * playback is ended.
     *
     * If the player was previously playing a resource and this method is called, the player will not transition to the
     * Idle state during the swap over.
     *
     * @param resource - The resource to play
     * @throws Will throw if attempting to play an audio resource that has already ended, or is being played by another player.
     */
    play<T>(resource: AudioResource<T>): void;
    /**
     * Pauses playback of the current resource, if any.
     *
     * @param interpolateSilence - If true, the player will play 5 packets of silence after pausing to prevent audio glitches.
     * @returns true if the player was successfully paused, otherwise false.
     */
    pause(interpolateSilence?: boolean): boolean;
    /**
     * Unpauses playback of the current resource, if any.
     *
     * @returns true if the player was successfully unpaused, otherwise false.
     */
    unpause(): boolean;
    /**
     * Stops playback of the current resource and destroys the resource. The player will either transition to the Idle state,
     * or remain in its current state until the silence padding frames of the resource have been played.
     *
     * @param force - If true, will force the player to enter the Idle state even if the resource has silence padding frames.
     * @returns true if the player will come to a stop, otherwise false.
     */
    stop(force?: boolean): boolean;
    /**
     * Checks whether the underlying resource (if any) is playable (readable).
     *
     * @returns true if the resource is playable, false otherwise.
     */
    checkPlayable(): boolean;
    /**
     * Called roughly every 20ms by the global audio player timer. Dispatches any audio packets that are buffered
     * by the active connections of this audio player.
     */
    private _stepDispatch;
    /**
     * Called roughly every 20ms by the global audio player timer. Attempts to read an audio packet from the
     * underlying resource of the stream, and then has all the active connections of the audio player prepare it
     * (encrypt it, append header data) so that it is ready to play at the start of the next cycle.
     */
    private _stepPrepare;
    /**
     * Signals to all the subscribed connections that they should send a packet to Discord indicating
     * they are no longer speaking. Called once playback of a resource ends.
     */
    private _signalStopSpeaking;
    /**
     * Instructs the given connections to each prepare this packet to be played at the start of the
     * next cycle.
     *
     * @param packet - The Opus packet to be prepared by each receiver
     * @param receivers - The connections that should play this packet
     */
    private _preparePacket;
}
/**
 * Creates a new AudioPlayer to be used
 */
export declare function createAudioPlayer(options?: CreateAudioPlayerOptions): AudioPlayer;
//# sourceMappingURL=AudioPlayer.d.ts.map